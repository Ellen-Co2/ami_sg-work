<<<<<<< Updated upstream
---
title: "canteen time series"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## read in data
```{r, echo=FALSE}
dat = read.csv("can_even.csv.txt",header = T)
library("tseries")
library("forecast")
library("ggplot2")
```
## using hour and week as period
```{r multi.seasonal, echo=FALSE}
ms.tr <- msts(dat[,2],c(12,(12*24*7)))
plot.ts(x = ms.tr)
```

## function 

use fourier and AICc to find optimal K combinations for different frequencies, maximum of freq not exceeding T/2
----
 eg: total 4 weeks, the maximum would no larger than 2
----
```{r fourier K}
find.k <- function(dat.ts,f1.min=1,f1.max,f2.min=1,f2.max,f3.max=NULL)
  {
  if (length(f3.max) < 1) {
aicc.tmp <- NULL
aicc.val <- NULL
for (i in f1.min:f1.max) {
  for (j in f2.min:f2.max) {
    x.fourier <- fourier(dat.ts,c(i,j))
    fitmd <- auto.arima(dat.ts, D = 0, max.P = 0, max.Q = 0, xreg = x.fourier,seasonal=FALSE,max.d=2, ic="aicc", allowdrift=TRUE)
    aicc.tmp <- cbind(i, j , fitmd$aicc ,arimaorder(fitmd)[1],arimaorder(fitmd)[2],arimaorder(fitmd)[3])
    aicc.val <- rbind(aicc.val,aicc.tmp)
  }
}
colnames(aicc.val) <- c("F1_terms","F2_terms","AICc","p","d","q")
aicc.val <- data.frame(aicc.val)
min.aicc <- min(aicc.val$AICc)
min.f <-aicc.val[which(aicc.val$AICc == min.aicc),]
}
  else {
  aicc.tmp <- NULL
  aicc.val <- NULL
for (i in 1:f1.max) {
  for (j in 1:f2.max) {
    for (k in 1:f3.max){
    x.fourier <- fourier(dat.ts,c(i,j,k))
    fitmd <- auto.arima(dat.ts, D = 0, max.P = 0, max.Q = 0, xreg = x.fourier,seasonal=FALSE,max.d=2, ic="aicc", allowdrift=TRUE)
    aicc.tmp <- cbind(i, j , k , fitmd$aicc)
    aicc.val <- rbind(aicc.val,aicc.tmp)
    }
  }
}
colnames(aicc.val) <- c("F1_terms","F2_terms","F3_terms","AICc")
aicc.val <- data.frame(aicc.val)
min.bic <- min(aicc.val$bic)
min.f <-aicc.val[which(aicc.val$bic == min.bic),]
  }
  return(min.f)
}
```
### Test with hour&week cycle
```{r hour&week}
ms.tr <- msts(dat[,2],c(12,(12*24*7)))
#find.k(ms.tr,6,2)
# f1 = 6 f2 = 1
```
### Test with day&week cycle
```{r day&week}
ms.dw <- msts(dat[,2],c((12*24),(12*24*7)))
#find.k(ms.dw,10,2)
#F1_terms F2_terms     AICc p d q
#13   10        1  62300.93 3 1 4
```
### using fft to find optimal freq
```{r fft, echo= F}
find.freq <- function(f.ts){
abs(fft(f.ts)/sqrt(length(f.ts)))^2-> I
Pow = I[1:as.integer(length(f.ts)/2)]
FREQ =(0:as.integer((length(Pow)-1)))/length(Pow)
plot(FREQ,Pow,type="l")
T1 <- data.frame(array(c(Pow,FREQ),dim=c(length(Pow),2)))
colnames(T1)<- c("Power","Frequency")

return (T1)
}
t1<-find.freq(dat[,2]) ## power 2nd has T=144/72
t2<- find.freq(diff(dat[,2]))
pow <- order(t2$Power,decreasing = T) # power highest T=28.79/24
ff1 <- 1/t2$Frequency[pow[1]]
```
### Produce forecasting use the Optimal K
```{r forecasting}
x.fd = fourier(ms.dw,c(7,1))
x.fdh = fourier(ms.dw,c(7,1), h = 12*24) #forecasting 24 hrs
best_md.day = auto.arima(ms.dw, D = 0, xreg = x.fd, max.d=3, ic="bic",seasonal = F, allowdrift=TRUE)
b_dfcast = forecast(best_md.day, xreg = x.fdh, h = 12*24)
Acf(best_md.day$residuals)# view the residuals as white noise

```

=======
---
title: "canteen time series"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## read in data
```{r, echo=FALSE}
dat = read.csv("can_even.csv.txt",header = T)
library("tseries")
library("forecast")
library("ggplot2")
```
## using hour and week as period
```{r multi.seasonal, echo=FALSE}
ms.tr <- msts(dat[,2],c(12,(12*24*7)))
plot.ts(x = ms.tr)
```

## function 

use fourier and AICc to find optimal K combinations for different frequencies, maximum of freq not exceeding T/2
----
 eg: total 4 weeks, the maximum would no larger than 2
----
```{r fourier K}
find.k <- function(dat.ts,f1.min=1,f1.max,f2.min=1,f2.max,f3.max=NULL)
  {
  if (length(f3.max) < 1) {
aicc.tmp <- NULL
aicc.val <- NULL
for (i in f1.min:f1.max) {
  for (j in f2.min:f2.max) {
    x.fourier <- fourier(dat.ts,c(i,j))
    fitmd <- auto.arima(dat.ts, D = 0, max.P = 0, max.Q = 0, xreg = x.fourier,seasonal=FALSE,max.d=2, ic="aicc", allowdrift=TRUE)
    aicc.tmp <- cbind(i, j , fitmd$aicc ,arimaorder(fitmd)[1],arimaorder(fitmd)[2],arimaorder(fitmd)[3])
    aicc.val <- rbind(aicc.val,aicc.tmp)
  }
}
colnames(aicc.val) <- c("F1_terms","F2_terms","AICc","p","d","q")
aicc.val <- data.frame(aicc.val)
min.aicc <- min(aicc.val$AICc)
min.f <-aicc.val[which(aicc.val$AICc == min.aicc),]
}
  else {
  aicc.tmp <- NULL
  aicc.val <- NULL
for (i in 1:f1.max) {
  for (j in 1:f2.max) {
    for (k in 1:f3.max){
    x.fourier <- fourier(dat.ts,c(i,j,k))
    fitmd <- auto.arima(dat.ts, D = 0, max.P = 0, max.Q = 0, xreg = x.fourier,seasonal=FALSE,max.d=2, ic="aicc", allowdrift=TRUE)
    aicc.tmp <- cbind(i, j , k , fitmd$aicc)
    aicc.val <- rbind(aicc.val,aicc.tmp)
    }
  }
}
colnames(aicc.val) <- c("F1_terms","F2_terms","F3_terms","AICc")
aicc.val <- data.frame(aicc.val)
min.bic <- min(aicc.val$bic)
min.f <-aicc.val[which(aicc.val$bic == min.bic),]
  }
  return(min.f)
}
```
### Test with hour&week cycle
```{r hour&week}
ms.tr <- msts(dat[,2],c(12,(12*24*7)))
#find.k(ms.tr,6,2)
# f1 = 6 f2 = 1
```
### Test with day&week cycle
```{r day&week}
ms.dw <- msts(dat[,2],c((12*24),(12*24*7)))
#find.k(ms.dw,7,2)
#F1_terms F2_terms     AICc p d q
#13     7        1 62300.93 3 1 4
```
### using fft to find optimal freq
```{r fft, echo= F}
find.freq <- function(f.ts){
abs(fft(f.ts)/sqrt(length(f.ts)))^2-> I
Pow = I[1:as.integer(length(f.ts)/2)]
FREQ =(0:as.integer((length(Pow)-1)))/length(Pow)
plot(FREQ,Pow,type="l")
T1 <- data.frame(array(c(Pow,FREQ),dim=c(length(Pow),2)))
colnames(T1)<- c("Power","Frequency")

return (T1)
}
t1<-find.freq(dat[,2]) ## power 2nd has T=144/72
t2<- find.freq(diff(dat[,2]))
pow <- order(t2$Power,decreasing = T) # power highest T=28.79/24
ff1 <- 1/t2$Frequency[pow[1]]
```
### Produce forecasting use the Optimal K
```{r forecasting}
x.fd = fourier(ms.dw,c(7,1))
x.fdh = fourier(ms.dw,c(7,1), h = 12*24) #forecasting 24 hrs
best_md.day = auto.arima(ms.dw, D = 0, xreg = x.fd, max.d=3, ic="bic",seasonal = F, allowdrift=TRUE)
b_dfcast = forecast(best_md.day, xreg = x.fdh, h = 12*24)
Acf(best_md.day$residuals)# view the residuals as white noise

```

>>>>>>> Stashed changes
